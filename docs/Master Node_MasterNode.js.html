<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Master Node/MasterNode.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Master Node/MasterNode.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*********************************************Node Code*****************************************************/

var sensors = [];
const net = require('net');
const fs = require('fs');

/**
* Creates the server that brokers the connections
*/
var server = net.createServer(function (socket) {
  socket.setNoDelay(true);

  socket.on('data', function (data) {

    //reads all incoming data
    const stringData = new Buffer(data).toString();

    console.log(stringData)

    //split it by the delimiter
    const command = stringData.split('-');

    //if the command new node is requested
    if (command[0] == 'nn') {

      //create a new sensor node object
      var sn = new SensorNode(command[1], command[2], command[3], command[4], socket);

      //check to see if the node is already in the list
      if (hasNode(sn) === false) {
        sensors.push(sn);
        io.sockets.emit('update-msg', {data: getTableString()});
      }

      sn.getSensorsToSubTo().forEach(function (s) {
        socket.write('ct-' + s.getString() + '*');
      });

      sn.getSensorsToPubTo();

    }
    else if(command[0] == 'cld'){

      for(var i =0 ; i &lt; sensors.length; i++){

        if(sensors[i].hostname == command[1]){
          sensors.splice(i, 1);
          break;
        }
      }
      io.sockets.emit('update-msg', {data: getTableString()});
    }
  });

  //ignore errors
  socket.on('error', function () {
  });

});

/**
*Returns string with all the connected nodes
*/
function getTableString() {
  var toReturn = '';

  sensors.forEach(function (s) {
    toReturn += s.getString() + '\n\r';
  })
  return toReturn;
}

/**
* Returns true if we have the node already in out table
* @param tosee
* @returns {boolean}
*/
function hasNode(tosee) {

  for (var i = 0; i &lt; sensors.length; i++) {

    if (sensors[i].isequal(tosee))
    return true;
  }
  return false;
}

function sendCommandToNodes(command) {

  sensors.forEach(function (s) {
    s.socket.write(command);
  });
}

/**
* Sensor node data type
* @param hostname
* @param ip
* @param sensors
* @constructor
*/
function SensorNode(hostname, ip, sensors, want, socket) {
  this.hostname = hostname;
  this.ip = ip;
  this.sensors = want !== undefined ? sensors.split(':') : [];
  this.want = want !== undefined ? want.split(':') : [];
  this.socket = socket
}

/**node
* ToString for sensor node
* @memberof SensorNode
* @returns {string}
*/
SensorNode.prototype.getString = function () {
  return this.hostname + '-' + this.ip + '-' + (this.sensors.length == 0 ? '' : this.sensors) + '-' + (this.want.length == 0 ? '' : this.want);
};

/**
* Returns array of sensors that have something it wants
* @param node
* @returns {Array}
*/
SensorNode.prototype.getSensorsToSubTo = function () {
  var toReturn = [];
  const that = this;

  sensors.forEach(function (s) {

    for (var w = 0; w &lt; that.want.length; w++) {

      if (s.sensors.indexOf(that.want[w]) >= 0 &amp;&amp; (s.sensors.length !== 0) &amp;&amp; (s.isequal(that) == false)) {
        toReturn.push(s);
        break;
      }
    }
  });

  return toReturn;
};

/**
* When a node joins the network it sees which other nodes want what the new one has and will send an update if it satisfies that condition
*/
SensorNode.prototype.getSensorsToPubTo = function () {
  const that = this;

  sensors.forEach(function (s) {

    for (var i = 0; i &lt; s.want.length; i++) {

      if (that.sensors.indexOf(s.want[i]) >= 0 &amp;&amp; (s.sensors.length !== 0) &amp;&amp; (s.isequal(that) == false)) {
        s.socket.write('ct-' + that.getString() + '*');
        break;
      }
    }
  });
};

/**
* Equality between sensor nodes
* @param node
* @returns {boolean}
*/
SensorNode.prototype.isequal = function (node) {

  return (this.ip == node.ip) &amp;&amp; (this.hostname == node.hostname);
}

//start listening for connections
server.listen(9999, '10.20.0.128');

/********************************************Website Code***************************************************/
const express = require('express');
const favicon = require('serve-favicon');
const app = express();
const path = require('path');
const scpClient = require('scp2');
const expressServer = app.listen(3000);

//create socket io for website to communicate with node server
var io = require('socket.io')(expressServer);

//stuff for styles
app.use(express.static(__dirname + '/'));
app.use(favicon(require('path').join(__dirname, '', 'favicon.ico')))

//called when the website is loaded
app.get('/', function (req, res) {

  //send the website code
  res.sendFile(__dirname + '/index.html')

  //update the table on refresh
  io.sockets.emit('update-msg', {data: getTableString()});
});

//look for a connection to the website socket
io.sockets.on('connection', function (socket) {

  socket.on('message', function(message){

    console.log(message);

    //filter commands from website
    if(message === 'shutdown'){
      sendCommandToNodes('shutdown');
    }
    else if (message === 'reboot') {
      sendCommandToNodes('reboot');
    }
    else if (message === 'refresh') {
      io.sockets.emit('update-msg', {data: getTableString()});
    }
    else if (message === 'logs') {
      getLogs();
    }

  });
})


//doesnt work :(
function getLogs() {
  sensors.forEach(function (s) {
    //scpClient.scp('logs/', 'root:cookiemonster@'+s.ip+':/home/root/.node_app_slot/logs/');
  });

}

console.log('website at localhost:3000')
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html">Client</a></li><li><a href="MasterNodeConnection.html">MasterNodeConnection</a></li><li><a href="SensorNode.html">SensorNode</a></li><li><a href="Server.html">Server</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getIPAddress">getIPAddress</a></li><li><a href="global.html#getTableString">getTableString</a></li><li><a href="global.html#hasNode">hasNode</a></li><li><a href="global.html#server">server</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Jun 22 2017 14:36:19 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
